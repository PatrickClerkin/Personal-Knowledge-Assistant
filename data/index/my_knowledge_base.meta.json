{
  "embedding_dim": 384,
  "chunks": [
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_0",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus. 1 \n \n \nComposition and Object Reuse \n \nOne of the principal goals of the object-oriented paradigm is to promote the reuse of software \nartefacts within an application and between applications. There are two basic mechanisms for \nachieving reuse in the paradigm \u2013 generalisation and composition.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 0,
      "end_char": 399,
      "chunk_index": 0,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_1",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "The former relates to the \nreuse of state and behaviour in concrete classes that are derived from a more abstract entity and \nimplicitly supports polymorphism. Composition relates to the construction of new types from \na collection of existing classes and represents the primary mechanism for reuse in the object-\noriented paradigm.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 399,
      "end_char": 731,
      "chunk_index": 1,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_2",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "While it is usually not cited as a \u201cpillar\u201d of the object-oriented paradigm, object reuse through \ncomposition is predicated on the proper application of abstraction and encapsulation. Indeed, \ncomposition promotes reuse precisely through the encapsulation of reusable behaviour in an \nabstract entity.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 731,
      "end_char": 1033,
      "chunk_index": 2,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_3",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Moreover, although inheritance and polymorphism are immediately identifiable \nas key pillars in the object-oriented paradigm, these concepts are also a consequence of the \napplication of abstraction and encapsulation. The whole point of encapsulation is to separate \nthe stable and volatile parts of an application into abstract and concrete types respectively.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1033,
      "end_char": 1394,
      "chunk_index": 3,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_4",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "The \nextracted abstract components are highly reusable as their generality confers upon them the \nflexibility to be used in a variety of different contexts. When not part of a clear hierarchy of \nresponsibility, such abstract entities should be reused through composition. When used \ncorrectly, composition enables behaviours and responsibilities to be dynamically assigned to \nan object at run-time. Implementation inheritance assigns behaviours and responsibilities \nstatically at compile time.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1394,
      "end_char": 1890,
      "chunk_index": 4,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_5",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Composition and Scope \nThere exist a number of different forms of composition that can be used in an application and \neach form is best categorised on the basis of the scope of the relationship between the container \nobject and the objects that it is composed with. Consider the following UML diagram that \nillustrates four forms of composition: \n \n \n \n \nThe diamonds denote a strong form of composition and require that the containing object \nmaintain an instance variable of that type.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1890,
      "end_char": 2377,
      "chunk_index": 5,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_6",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "For example, the type C should have instance \nvariables of type A and E, defined at a class level. The full line represents an association \nbetween class C and class D, where the classes interact with another class at a method level. The dashed line denotes a dependency, the weakest form of composition. When an object has \n\nAdvanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 2377,
      "end_char": 2807,
      "chunk_index": 6,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_7",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "2 \ngone out of scope, the JVM will invoke the inherited finalize() method before the garbage \ncollector removes the instance from the heap. The finalize() method can thus be used to \ndetermine the scope of a composed object and the exact form of composition it manifests. There are four basic forms of composition: \n \n1. Dependency (Dashed Line with Arrow): the scope of composition is restricted to the \nimplementation details of a method.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 2807,
      "end_char": 3247,
      "chunk_index": 7,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_8",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "The dependency is not visible or accessible outside \nthe containing class in any way. The composed object is normally fully encapsulated, \nbut may also be shared if singletons are being used. 2. Association (Fill Line with Arrow):  The scope of a composed object is outside of the \nclass itself, as the composed object is either passed in as a method argument or returned \nas a type from the method. Either way, the method invocator will have a reference to \nthe composed object at that point in time. 3.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 3247,
      "end_char": 3751,
      "chunk_index": 8,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_9",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "3. Aggregation (White Diamond with Arrow): The composed object is declared at a \nclass level, i.e. has the scope of an instance variable. An external call may have direct \naccess to the composed object if it passed the object to the constructor of a container \nclass. Indirect access to the composed object can arise from returning a reference to a \nmutable instance variable from an accessor method.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 3749,
      "end_char": 4149,
      "chunk_index": 9,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_10",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "In an aggregation relationship, the \ncomposed object may be referenced by some other object and thus may have a scope \ngreater than its container. Consequently, if the container goes out of scope and is \ngarbage collected, the composed object may outlive its container. 4. Full Composition  (Black Diamond with Arrow): The composed object is \ncompletely encapsulated inside the containing class, with no possibility of direct or \nindirect access.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 4149,
      "end_char": 4595,
      "chunk_index": 10,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_11",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "The scope of the composed object is thus restricted to the class using \nit. Consequently, when the containing class goes out of scope and is garbage collected, \nthe composed class is guaranteed to be garbage collected with it. Note that composition and delegation go hand-in-glove. The whole point of composing objects \nis to reuse their behaviour in another class. That reuse of behaviour relates to the invocation of \nthe methods exposed by the composed class.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 4595,
      "end_char": 5057,
      "chunk_index": 11,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_12",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Consequently, the methods of the containing class \nshould delegate tasks to composed objects where possible. It is important to realise that, using \ncomposition, a class can be capable of doing many different things without violating the Single \nResponsibility Principle.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5057,
      "end_char": 5328,
      "chunk_index": 12,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_13",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Finalise \n \n \nExercises \nIn this practical, we will employ composition to reuse the cryptographic capability already \nprovided in the Java SDK and explore how composition can be combined with abstraction \nand encapsulation to create cohesive and loosely coupled designs.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5328,
      "end_char": 5598,
      "chunk_index": 13,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_14",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "\u2022 \nUsing Eclipse create a new class called RSACypher, composed with the following \ninstance variables imported from the java.security an javax.crypto APIs:  \no Cipher cypher  \no KeyPair keyRing \n \nOverride the inherited method finalize() to output the name of the class and its Object \nID. Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5598,
      "end_char": 5992,
      "chunk_index": 14,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_15",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "3 \n\u2022 \nIn the constructor of RSACypher, implement the functionality to initialise both \ninstance variables as follows: \n \nKeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\"); \nkeyGen.initialize(2048); \nkeyRing = keyGen.generateKeyPair(); \ncypher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); \n \nExplain the scope of the three variables defined and the form of composition for \neach.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 5992,
      "end_char": 6383,
      "chunk_index": 15,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_16",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "\u2022 \nDeclare the following two methods for encryption and decryption: \n \npublic byte[] encrypt(byte[] plainText) throws Throwable{ \npublic byte[] decrypt(byte[] cypherText) throws Throwable{ \n \nImplement each method by calling the init() method of cypher with the appropriate \nparameters. Use the key returned by keyRing.getPublic() and keyRing.getPublic() for \nencryption and decryption respectively.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6383,
      "end_char": 6782,
      "chunk_index": 16,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_17",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "\u2022 \nCreate a TestRunner class with a main method and exercise the functionality of the \nclass to ensure that it works correctly. \u2022 \nConsider the following code required to encrypt using the DES and AES standards.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6782,
      "end_char": 6993,
      "chunk_index": 17,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_18",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "Note that DES and AES are symmetric cryptographic methods: \n \nKeyGenerator keyGen = KeyGenerator.getInstance(\"DES\"); \nkeyGen.init(128);  \nkey key = keyGen.generateKey(); \nCipher cypher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\") \ncypher.init(Cipher.DECRYPT_MODE, key); \nbytep[] result =  cypher.doFinal(cypherText); \n \nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");  \nkeyGen.init(128);  \nkey key = keyGen.generateKey(); \nCipher cypher  = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); \ncypher.init(Cipher.DECRYPT_MODE, key); \nbytep[] result =  cypher.doFinal(cypherText); \n \nIdentify and implement the alterations to the class RSACypher required to ensure \ncompatibility with symmetric keys.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6993,
      "end_char": 7690,
      "chunk_index": 18,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_19",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "\u2022 \nUsing the refactoring menu, exact a superclass called AbstractCypher from the class \nRSACypher that contains a corpus of reusable code. Use abstract methods where \nappropriate. Explain the impact that this action has on the overall design of the \napplication. Create two new classes called DESCypher and AESCypher that directly inherit from \nAbstractCypher and implement the remaining code required to complete the \nfunctionality of each class.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 7690,
      "end_char": 8137,
      "chunk_index": 19,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_20",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "In each class, override the inherited method finalize() to \noutput the name of the class and its Object ID. \u2022 \nUsing the refactoring menu, extract an interface called Cypherable from the class \nAbstractCypher and alter the type used in TestRunner to the new interface. Explain \nthe impact that this action has on the overall design of the application. Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 8137,
      "end_char": 8593,
      "chunk_index": 20,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_21",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "4 \n \n\u2022 \nCreate an enum called CypherType with the options of AES, DES and RSA.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 4,
      "start_char": 8593,
      "end_char": 8671,
      "chunk_index": 21,
      "total_chunks": 23
    },
    {
      "chunk_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c_chunk_22",
      "doc_id": "df6d9ea9160190ba86c8f2ea7c1d7b4c",
      "content": "\u2022 \nCreate a new class called CypherFactory defined as follows and alter TestRunner to \nreturn the type returned by the factory method: \n \npublic class CypherFactory { \n   private static CypherFactory f = new Throwable(); \n \n \n   private CypherFactory(){} \n \n \n   public static CypherFactory getInstance(){ \n      return f; \n   } \n \n \n   public Cypherable getCypher(CypherType type) throws Throwable { \n      if (type == CypherType.DES) { \n         return new DESCypher(); \n      }else if (type == CypherType.RSA) { \n         return new RSACypher(); \n      }else {  \n         return new AESCypher(); \n      } \n \n \n   } \n} \n \n \nExplain the impact that this action has on the overall design of the application.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 4,
      "start_char": 8671,
      "end_char": 9378,
      "chunk_index": 22,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_0",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus. 1 \n \n \nComposition and Object Reuse \n \nOne of the principal goals of the object-oriented paradigm is to promote the reuse of software \nartefacts within an application and between applications. There are two basic mechanisms for \nachieving reuse in the paradigm \u2013 generalisation and composition.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 0,
      "end_char": 399,
      "chunk_index": 0,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_1",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "The former relates to the \nreuse of state and behaviour in concrete classes that are derived from a more abstract entity and \nimplicitly supports polymorphism. Composition relates to the construction of new types from \na collection of existing classes and represents the primary mechanism for reuse in the object-\noriented paradigm.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 399,
      "end_char": 731,
      "chunk_index": 1,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_2",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "While it is usually not cited as a \u201cpillar\u201d of the object-oriented paradigm, object reuse through \ncomposition is predicated on the proper application of abstraction and encapsulation. Indeed, \ncomposition promotes reuse precisely through the encapsulation of reusable behaviour in an \nabstract entity.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 731,
      "end_char": 1033,
      "chunk_index": 2,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_3",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Moreover, although inheritance and polymorphism are immediately identifiable \nas key pillars in the object-oriented paradigm, these concepts are also a consequence of the \napplication of abstraction and encapsulation. The whole point of encapsulation is to separate \nthe stable and volatile parts of an application into abstract and concrete types respectively.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1033,
      "end_char": 1394,
      "chunk_index": 3,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_4",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "The \nextracted abstract components are highly reusable as their generality confers upon them the \nflexibility to be used in a variety of different contexts. When not part of a clear hierarchy of \nresponsibility, such abstract entities should be reused through composition. When used \ncorrectly, composition enables behaviours and responsibilities to be dynamically assigned to \nan object at run-time. Implementation inheritance assigns behaviours and responsibilities \nstatically at compile time.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1394,
      "end_char": 1890,
      "chunk_index": 4,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_5",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Composition and Scope \nThere exist a number of different forms of composition that can be used in an application and \neach form is best categorised on the basis of the scope of the relationship between the container \nobject and the objects that it is composed with. Consider the following UML diagram that \nillustrates four forms of composition: \n \n \n \n \nThe diamonds denote a strong form of composition and require that the containing object \nmaintain an instance variable of that type.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 1890,
      "end_char": 2377,
      "chunk_index": 5,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_6",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "For example, the type C should have instance \nvariables of type A and E, defined at a class level. The full line represents an association \nbetween class C and class D, where the classes interact with another class at a method level. The dashed line denotes a dependency, the weakest form of composition. When an object has \n\nAdvanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 1,
      "start_char": 2377,
      "end_char": 2807,
      "chunk_index": 6,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_7",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "2 \ngone out of scope, the JVM will invoke the inherited finalize() method before the garbage \ncollector removes the instance from the heap. The finalize() method can thus be used to \ndetermine the scope of a composed object and the exact form of composition it manifests. There are four basic forms of composition: \n \n1. Dependency (Dashed Line with Arrow): the scope of composition is restricted to the \nimplementation details of a method.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 2807,
      "end_char": 3247,
      "chunk_index": 7,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_8",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "The dependency is not visible or accessible outside \nthe containing class in any way. The composed object is normally fully encapsulated, \nbut may also be shared if singletons are being used. 2. Association (Fill Line with Arrow):  The scope of a composed object is outside of the \nclass itself, as the composed object is either passed in as a method argument or returned \nas a type from the method. Either way, the method invocator will have a reference to \nthe composed object at that point in time. 3.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 3247,
      "end_char": 3751,
      "chunk_index": 8,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_9",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "3. Aggregation (White Diamond with Arrow): The composed object is declared at a \nclass level, i.e. has the scope of an instance variable. An external call may have direct \naccess to the composed object if it passed the object to the constructor of a container \nclass. Indirect access to the composed object can arise from returning a reference to a \nmutable instance variable from an accessor method.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 3749,
      "end_char": 4149,
      "chunk_index": 9,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_10",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "In an aggregation relationship, the \ncomposed object may be referenced by some other object and thus may have a scope \ngreater than its container. Consequently, if the container goes out of scope and is \ngarbage collected, the composed object may outlive its container. 4. Full Composition  (Black Diamond with Arrow): The composed object is \ncompletely encapsulated inside the containing class, with no possibility of direct or \nindirect access.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 4149,
      "end_char": 4595,
      "chunk_index": 10,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_11",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "The scope of the composed object is thus restricted to the class using \nit. Consequently, when the containing class goes out of scope and is garbage collected, \nthe composed class is guaranteed to be garbage collected with it. Note that composition and delegation go hand-in-glove. The whole point of composing objects \nis to reuse their behaviour in another class. That reuse of behaviour relates to the invocation of \nthe methods exposed by the composed class.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 4595,
      "end_char": 5057,
      "chunk_index": 11,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_12",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Consequently, the methods of the containing class \nshould delegate tasks to composed objects where possible. It is important to realise that, using \ncomposition, a class can be capable of doing many different things without violating the Single \nResponsibility Principle.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5057,
      "end_char": 5328,
      "chunk_index": 12,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_13",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Finalise \n \n \nExercises \nIn this practical, we will employ composition to reuse the cryptographic capability already \nprovided in the Java SDK and explore how composition can be combined with abstraction \nand encapsulation to create cohesive and loosely coupled designs.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5328,
      "end_char": 5598,
      "chunk_index": 13,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_14",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "\u2022 \nUsing Eclipse create a new class called RSACypher, composed with the following \ninstance variables imported from the java.security an javax.crypto APIs:  \no Cipher cypher  \no KeyPair keyRing \n \nOverride the inherited method finalize() to output the name of the class and its Object \nID. Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 2,
      "start_char": 5598,
      "end_char": 5992,
      "chunk_index": 14,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_15",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "3 \n\u2022 \nIn the constructor of RSACypher, implement the functionality to initialise both \ninstance variables as follows: \n \nKeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\"); \nkeyGen.initialize(2048); \nkeyRing = keyGen.generateKeyPair(); \ncypher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); \n \nExplain the scope of the three variables defined and the form of composition for \neach.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 5992,
      "end_char": 6383,
      "chunk_index": 15,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_16",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "\u2022 \nDeclare the following two methods for encryption and decryption: \n \npublic byte[] encrypt(byte[] plainText) throws Throwable{ \npublic byte[] decrypt(byte[] cypherText) throws Throwable{ \n \nImplement each method by calling the init() method of cypher with the appropriate \nparameters. Use the key returned by keyRing.getPublic() and keyRing.getPublic() for \nencryption and decryption respectively.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6383,
      "end_char": 6782,
      "chunk_index": 16,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_17",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "\u2022 \nCreate a TestRunner class with a main method and exercise the functionality of the \nclass to ensure that it works correctly. \u2022 \nConsider the following code required to encrypt using the DES and AES standards.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6782,
      "end_char": 6993,
      "chunk_index": 17,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_18",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "Note that DES and AES are symmetric cryptographic methods: \n \nKeyGenerator keyGen = KeyGenerator.getInstance(\"DES\"); \nkeyGen.init(128);  \nkey key = keyGen.generateKey(); \nCipher cypher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\") \ncypher.init(Cipher.DECRYPT_MODE, key); \nbytep[] result =  cypher.doFinal(cypherText); \n \nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");  \nkeyGen.init(128);  \nkey key = keyGen.generateKey(); \nCipher cypher  = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); \ncypher.init(Cipher.DECRYPT_MODE, key); \nbytep[] result =  cypher.doFinal(cypherText); \n \nIdentify and implement the alterations to the class RSACypher required to ensure \ncompatibility with symmetric keys.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 6993,
      "end_char": 7690,
      "chunk_index": 18,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_19",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "\u2022 \nUsing the refactoring menu, exact a superclass called AbstractCypher from the class \nRSACypher that contains a corpus of reusable code. Use abstract methods where \nappropriate. Explain the impact that this action has on the overall design of the \napplication. Create two new classes called DESCypher and AESCypher that directly inherit from \nAbstractCypher and implement the remaining code required to complete the \nfunctionality of each class.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 7690,
      "end_char": 8137,
      "chunk_index": 19,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_20",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "In each class, override the inherited method finalize() to \noutput the name of the class and its Object ID. \u2022 \nUsing the refactoring menu, extract an interface called Cypherable from the class \nAbstractCypher and alter the type used in TestRunner to the new interface. Explain \nthe impact that this action has on the overall design of the application. Advanced Software Design   \n \nDepartment of Computer Science & Applied Physics, ATU, Galway City Campus.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 3,
      "start_char": 8137,
      "end_char": 8593,
      "chunk_index": 20,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_21",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "4 \n \n\u2022 \nCreate an enum called CypherType with the options of AES, DES and RSA.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 4,
      "start_char": 8593,
      "end_char": 8671,
      "chunk_index": 21,
      "total_chunks": 23
    },
    {
      "chunk_id": "4719183f7ca94b204a2c38261afacd3f_chunk_22",
      "doc_id": "4719183f7ca94b204a2c38261afacd3f",
      "content": "\u2022 \nCreate a new class called CypherFactory defined as follows and alter TestRunner to \nreturn the type returned by the factory method: \n \npublic class CypherFactory { \n   private static CypherFactory f = new Throwable(); \n \n \n   private CypherFactory(){} \n \n \n   public static CypherFactory getInstance(){ \n      return f; \n   } \n \n \n   public Cypherable getCypher(CypherType type) throws Throwable { \n      if (type == CypherType.DES) { \n         return new DESCypher(); \n      }else if (type == CypherType.RSA) { \n         return new RSACypher(); \n      }else {  \n         return new AESCypher(); \n      } \n \n \n   } \n} \n \n \nExplain the impact that this action has on the overall design of the application.",
      "source_doc_title": "aswdCompositionLab",
      "section_id": null,
      "page_number": 4,
      "start_char": 8671,
      "end_char": 9378,
      "chunk_index": 22,
      "total_chunks": 23
    }
  ]
}